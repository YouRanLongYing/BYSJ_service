// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Text;


namespace SimpleService
{
	public class Protocol
	{
		//var Protocol = exports;
		
		private const int PKG_HEAD_BYTES = 4;
		private const int MSG_FLAG_BYTES = 1;
		private const int MSG_ROUTE_CODE_BYTES = 2;
		private const int MSG_ID_MAX_BYTES = 5;
		private const int MSG_ROUTE_LEN_BYTES = 1;
		
		private const int MSG_ROUTE_CODE_MAX = 0xffff;
		
		private const int MSG_COMPRESS_ROUTE_MASK = 0x1;
		private const int MSG_TYPE_MASK = 0x7;
		




		public Protocol ()
		{

		}



		public static byte[] PackageEncode(Package package)
		{
			return PackageEncode(package.PType,package.Data);
		}

	/// <summary>
		/// Package protocol encode.
		/// 
		/// /// Pomelo package format:
		/// +------+-------------+------------------+
		///	 | type | body length |       body       |
		///		 +------+-------------+------------------+
		///		
		///		Head: 4bytes
		///		   0: package type,
		///		     1 - handshake,
		///		     2 - handshake ack,
		///		     3 - heartbeat,
		///		     4 - data
		///		     5 - kick
		///		  1 - 3: big-endian body length
		///		Body: body length bytes
		/// </summary>
		/// <returns>new byte array that contains encode result</returns>
		/// <param name="type"> type   package type</param>
		/// <param name="body">body content in bytes</param>
		public static byte[] PackageEncode(PackageType type,byte[] body)
		{
			int length = (body!=null) ? body.Length : 0;
			byte[] buffer = new byte[PKG_HEAD_BYTES + length];
			int index = 0;
			buffer[index++] = (byte)((int)type  & 0xff);
			buffer[index++] = (byte) ((length >> 16) & 0xff);
			buffer[index++] =  (byte)((length >> 8) & 0xff);
			buffer[index++] = (byte) (length & 0xff);
			if(body!=null) 
			{
				CopyArray(buffer, index, body, 0, length);
			}
			return buffer;
		}

		static void CopyArray(byte[] target,int index,byte[] source,int offset,int length)
		{
			for(int i=0;i<length;i++)
			{
				target[i+index]=source[i+offset];
			}
		}


		/// <summary>
		///  Package protocol encode.
		/// Pomelo package format:
		/// +------+-------------+------------------+
		///	 | type | body length |       body       |
		///		 +------+-------------+------------------+
		///		
		///		Head: 4bytes
		///		   0: package type,
		///		     1 - handshake,
		///		     2 - handshake ack,
		///		     3 - heartbeat,
		///		     4 - data
		///		     5 - kick
		///		  1 - 3: big-endian body length
		///		Body: body length bytes
		/// </summary>
		/// <returns>type: package type, buffer: body byte array</returns>
		/// <param name="buffer">buffer byte array containing package content</param>
		public static Package PackageDecode(byte[] buffer)
		{
			int offset = 0;
			byte[] bytes = buffer;
			int length = 0;
			Package package=new Package();
			if(offset < bytes.Length)
			{
				byte type = bytes[offset++];
				length = ((bytes[offset++]) << 16 | (bytes[offset++]) << 8 | bytes[offset++]) >> 0 ;
				byte[] body = (length!=0) ? new byte[length] : null;
				if(body!=null)
				{
					CopyArray(body, 0, bytes, offset, length);
					//TODO:修复多包和掉包的情况
//					if(body.Length==bytes.Length+4)//一个包
//						CopyArray(body, 0, bytes, offset, length);
//					else if(body.Length>bytes.Length+4)//包不够大
//					{
//
//					}
//					else//包多了
//					{
//
//					}
				}
				offset += length;
				PackageType RStype=(PackageType)((int)type);
				package.PType=RStype;
				package.Data=body;
			}
			return package;
		}

		/// <summary>
		/// Strings the encode. UTF-8
		/// </summary>
		/// <returns>The encode.</returns>
		/// <param name="str">String.</param>
		public static byte[] StrEncode (string str) 
		{
			return Encoding.UTF8.GetBytes( System.Convert.ToBase64String( Encoding.UTF8.GetBytes( str )));
//			if(true)
//			{
//				// encoding defaults to 'utf8'
//				return (new Buffer(str));
//			} else 
//			{
//				var byteArray = new byte[str.length * 3];
//				var offset = 0;
//				for(var i = 0; i < str.length; i++)
//				{
//					var charCode = str.charCodeAt(i);
//					var codes = null;
//					if(charCode <= 0x7f)
//					{
//						codes = [charCode];
//					}
//					else if(charCode <= 0x7ff)
//					{
//						codes = [0xc0|(charCode>>6), 0x80|(charCode & 0x3f)];
//					}
//					else
//					{
//						codes = [0xe0|(charCode>>12), 0x80|((charCode & 0xfc0)>>6), 0x80|(charCode & 0x3f)];
//					}
//					for(var j = 0; j < codes.length; j++)
//					{
//						byteArray[offset] = codes[j];
//						++offset;
//					}
//				}
//				var _buffer = new ByteArray(offset);
//				copyArray(_buffer, 0, byteArray, 0, offset);
//				return _buffer;
//			}
		}

		/**
   * client decode
   * msg String data
   * return Message Object
   */
		public string StrDecode(byte[] buffer) {
			return Encoding.UTF8.GetString(buffer);

//			if(typeof Buffer !== "undefined" && ByteArray === Buffer) {
//				// encoding defaults to 'utf8'
//				return buffer.toString();
//			} else {
//				var bytes = new ByteArray(buffer);
//				var array = [];
//				var offset = 0;
//				var charCode = 0;
//				var end = bytes.length;
//				while(offset < end){
//					if(bytes[offset] < 128){
//						charCode = bytes[offset];
//						offset += 1;
//					}else if(bytes[offset] < 224){
//						charCode = ((bytes[offset] & 0x1f)<<6) + (bytes[offset+1] & 0x3f);
//						offset += 2;
//					}else{
//						charCode = ((bytes[offset] & 0x0f)<<12) + ((bytes[offset+1] & 0x3f)<<6) + (bytes[offset+2] & 0x3f);
//						offset += 3;
//					}
//					array.push(charCode);
//				}
//				return String.fromCharCode.apply(null, array);
//			}
		}

	}

	public class Package
	{
		private PackageType pType=PackageType.TYPE_DATA;
		private byte[] data;

		public PackageType PType {
			get {
				return pType;
			}
			set {
				pType = value;
			}
		}

		public byte[] Data {
			get {
				return data;
			}
			set {
				data = value;
			}
		}
	}

	public enum PackageType
	{
		TYPE_HANDSHAKE = 1,
		TYPE_HANDSHAKE_ACK = 2,
		TYPE_HEARTBEAT = 3,
		TYPE_DATA = 4,
		TYPE_KICK = 5,
	}
	
	public enum MessageType
	{
		TYPE_REQUEST = 0,
		TYPE_NOTIFY = 1,
		TYPE_RESPONSE = 2,
		TYPE_PUSH = 3,
	}


}

